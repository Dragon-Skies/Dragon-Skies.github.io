<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://dragon-skies.github.io/</id>
    <title>Dragon Skies&apos; Blog</title>
    <updated>2020-06-24T12:54:15.267Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://dragon-skies.github.io/"/>
    <link rel="self" href="https://dragon-skies.github.io/atom.xml"/>
    <subtitle>Make By : Dragon Skies.

From No.10 Middle School.</subtitle>
    <logo>https://dragon-skies.github.io/images/avatar.png</logo>
    <icon>https://dragon-skies.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Dragon Skies&apos; Blog</rights>
    <entry>
        <title type="html"><![CDATA[2019~2020年第二学期第三次月考分数代码]]></title>
        <id>https://dragon-skies.github.io/post/2019~2020 the third score/</id>
        <link href="https://dragon-skies.github.io/post/2019~2020 the third score/">
        </link>
        <updated>2020-06-24T12:32:57.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-py">import xlrd
import xlwt
import os


def open_excel(file='test.xlsx'):
    try:
        data = xlrd.open_workbook(file)
        return data
    except:
        pass


def read_excel(filename):
    wd = open_excel(filename)
    table = wd.sheets()[0]
    row = table.nrows
    col = table.ncols
    List = []
    for i in range(row):
        List.append([])
        for j in range(col):
            List[i].append(table.cell(i, j).value)
    return List


def write_excel(namelist, savename, savebool=True):
    # namelist格式要求,为二维数组,namelist[i]表示第i+1行需要写入的内容
    row = len(namelist)
    col = len(namelist[0])
    workbook = xlwt.Workbook()
    worksheet = workbook.add_sheet('New Sheet')
    for i in range(row):
        for j in range(col):
            worksheet.write(i, j, namelist[i][j])
    if(savebool):
        workbook.save(savename)
    else:
        return workbook

'''
List = read_excel(&quot;开学考试进退.xlsx&quot;)
#print(List)
last = {}
now = {}
end = {}
List.pop(0)
for i in List:
    last[i[0]]=now[i[0]]=0
for i in range(len(List)):
    last[List[i][0]]=List[i][1]
    now[List[i][2]]=List[i][3]
List = [['姓名','期末考试排名','开学考试排名','进退']]
num=1
for i in last.keys():
    List.append([])
    List[num].append(i)
    List[num].append(last[i])
    List[num].append(now[i])
    List[num].append(last[i]-now[i])
    num+=1
write_excel(List,&quot;上次进退.xlsx&quot;)
'''

def count(al,now):
    if(now&gt;=al*0.9):
        return (now-(al*0.8)+1)*20
    if(now&gt;=al*0.8):
        return (now-(al*0.8)+1)*10
    if(now&lt;=al*0.7):
        return (now-al*0.7)*100
    return 0

def re_list_to_dict(List):
    now = {}
    for i in List:
        tmp = i[:]
        tmp.pop(0)
        now[i[0]] = tmp
    return now

List = read_excel(&quot;score.xls&quot;)
List.pop(0)
#print(List)
write_list = [['姓名','政治','政治得分','历史','历史得分','地理','地理得分','生物','生物得分','本次年排','本次年排得分','本次进退','本次进退得分','开学考试年排','期末考试年排','上次进退得分','奖状得分','总分']]
#'姓名','政治','政治得分','历史','历史得分','地理','地理得分','生物','生物得分'，
#'本次年排','本次年排得分','本次进退','本次进退得分','开学考试年排','期末考试年排',
#'上次进退得分','奖状得分','总分'
last = read_excel(&quot;上次进退.xlsx&quot;)
last.pop(0)
last = re_list_to_dict(last)
#print(last)
for i in range(len(List)):
    num=0
    write_list.append([])
    write_list[i+1].append(List[i][0])
    write_list[i+1].append(List[i][1])
    write_list[i+1].append(count(70,List[i][1]))
    num+=count(70,List[i][1])
    write_list[i+1].append(List[i][2])
    write_list[i+1].append(count(50,List[i][2]))
    num+=count(50,List[i][2])
    write_list[i+1].append(List[i][3])
    write_list[i+1].append(count(30,List[i][3]))
    num+=count(30,List[i][3])
    write_list[i+1].append(List[i][4])
    write_list[i+1].append(count(30,List[i][4]))
    num+=count(30,List[i][4])
    write_list[i+1].append(List[i][5])
    write_list[i+1].append(1370-List[i][5])
    num+=1370-List[i][5]
    write_list[i+1].append(List[i][6])
    write_list[i+1].append(List[i][6]*2)
    num+=List[i][6]*2
    if(List[i][0]!='曾祥淳'):
        write_list[i+1].append(last[List[i][0]][1])
        write_list[i+1].append(last[List[i][0]][0])
        if((last[List[i][0]][1]-last[List[i][0]][0])*(-2)&lt;0):
            write_list[i+1].append(0)
        else:
            write_list[i+1].append((last[List[i][0]][1]-last[List[i][0]][0])*(-2))
            num += (last[List[i][0]][1]-last[List[i][0]][0])*(-2)
        if(last[List[i][0]][0]&lt;=300):
            write_list[i+1].append(30)
            num+=30
        else:
            write_list[i+1].append(0)
    else:
        write_list[i+1].append(0)
        write_list[i+1].append(0)
        write_list[i+1].append(0)
        write_list[i+1].append(0)
    write_list[i+1].append(num)

write_excel(write_list,&quot;end_score.xlsx&quot;)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 U107929【数的拆分】]]></title>
        <id>https://dragon-skies.github.io/post/U107929/</id>
        <link href="https://dragon-skies.github.io/post/U107929/">
        </link>
        <updated>2020-03-02T09:48:35.000Z</updated>
        <content type="html"><![CDATA[<p>原本是 <code>NKZX_OJ</code> 的题目，这里是 <code>Dragon_Skies</code> 造的数据，数据保证无误。</p>
<p>这一题调了我好久，一开始想对每个数进行一个标记，然后DFS的时候判断一下有没有标记。</p>
<p>然而这样并不行。</p>
<p>于是转变思路，干脆全部暴力枚举，然后当DFS最后得到 <code>dfs(0)</code> 的时候，判断一下数列是不是单调上升，就完美解决了（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>≤</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">N \leq 20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span>）。</p>
<p>所谓单调上升，就是数列的每一项都 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo></mrow><annotation encoding="application/x-tex">\geq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span></span></span></span> 前面一项。（这里是可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>=</mo></mrow><annotation encoding="application/x-tex">=</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span> 的）</p>
<p>于是就很好写，先写出输出和判断的函数：</p>
<pre><code class="language-cpp">int n,tot,a[25],ans; //n是输入的数,tot记录当前拆了几个数,ans记录总个数。
bool check(){        //判断函数
	for(int i=2;i&lt;=tot;i++)if(a[i]&lt;a[i-1]) return false;     //如果不判组单调上升，返回不合法
	return true;                                             //否则就满足，返回真
}
void print(){
	cout&lt;&lt;a[1];                                      //先输出第一项，然后再输出'+',就不会格式混乱
	for(int i=2;i&lt;=tot;i++) cout&lt;&lt;'+'&lt;&lt;a[i];
	cout&lt;&lt;endl;                                      //要输出换行
	return;
}
</code></pre>
<p>然后就是 <code>DFS</code>：</p>
<pre><code class="language-cpp">void dfs(int x){                     //当前还要拆 x 个数
	if(x==0){                        //不需要拆了
		if(check())                  //如果合法
			print(),ans++;           //打印路径，答案++
		return;                      //退出
	}
	for(int i=1;i&lt;=x;i++){           //还要拆，那就一个一个枚举
		a[++tot]=i;dfs(x-i);tot--;   //搜索+回溯
	}
	return;
}
</code></pre>
<p>于是，整个题目就解出来了。</p>
<p>答案：</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,tot,a[25],ans;
bool check(){
	for(int i=2;i&lt;=tot;i++)if(a[i]&lt;a[i-1]) return false;
	return true;
}
void print(){
	cout&lt;&lt;a[1];
	for(int i=2;i&lt;=tot;i++) cout&lt;&lt;'+'&lt;&lt;a[i];
	cout&lt;&lt;endl;
	return;
}
void dfs(int x){
	if(x==0){
		if(check())
			print(),ans++;
		return;
	}
	for(int i=1;i&lt;=x;i++){
		a[++tot]=i;dfs(x-i);tot--;
	}
	return;
}
int main(){
	ios::sync_with_stdio(false);
	cin&gt;&gt;n;
	dfs(n);
	cout&lt;&lt;&quot;total=&quot;&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>难度不是很大。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++提高数据结构模板]]></title>
        <id>https://dragon-skies.github.io/post/TGmodel-shujujiegou/</id>
        <link href="https://dragon-skies.github.io/post/TGmodel-shujujiegou/">
        </link>
        <updated>2020-03-01T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1线段树">1.线段树</h2>
<pre><code class="language-c++">#define N 100001
#define ll long long
ll t[N&lt;&lt;2],add[N&lt;&lt;2];
inline void pushup(ll o){t[o]=t[o&lt;&lt;1]+t[o&lt;&lt;1|1];}
inline void build(ll o,ll l,ll r){
	if(l==r){cin&gt;&gt;t[o];return;}
	ll mid=(l+r)/2;
	build(o&lt;&lt;1,l,mid);
	build(o&lt;&lt;1|1,mid+1,r);
	pushup(o);
}
inline void pushdown(ll o,ll l,ll r){
	if(add[o]==0) return;
	ll mid=(l+r)&gt;&gt;1;
	add[o&lt;&lt;1]+=add[o];
	add[o&lt;&lt;1|1]+=add[o];
	t[o&lt;&lt;1]+=add[o]*(mid-l+1);
	t[o&lt;&lt;1|1]+=add[o]*(r-mid);
	add[o]=0;
	return;
}
inline void puttag(ll o,ll l,ll r,ll v){
	add[o]+=v;t[o]+=(r-l+1)*v;
}
inline void optadd(ll o,ll l,ll r,ll ql,ll qr,ll v){
	if(ql&lt;=l&amp;&amp;r&lt;=qr){puttag(o,l,r,v);return;}
	ll mid=(l+r)&gt;&gt;1;
	pushdown(o,l,r);
	if(ql&lt;=mid) optadd(o&lt;&lt;1,l,mid,ql,qr,v);
	if(qr&gt;mid) optadd(o&lt;&lt;1|1,mid+1,r,ql,qr,v);
	pushup(o);
}
inline ll querysum(ll o,ll l,ll r,ll ql,ll qr){
	if(ql&lt;=l&amp;&amp;r&lt;=qr) return t[o];
	ll ans=0,mid=(l+r)&gt;&gt;1;
	pushdown(o,l,r);
	if(ql&lt;=mid) ans+=querysum(o&lt;&lt;1,l,mid,ql,qr);
	if(qr&gt;mid)  ans+=querysum(o&lt;&lt;1|1,mid+1,r,ql,qr);
	return ans;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 题解 SP27320【VECTAR10 - Card Game】]]></title>
        <id>https://dragon-skies.github.io/post/SP27320/</id>
        <link href="https://dragon-skies.github.io/post/SP27320/">
        </link>
        <updated>2020-03-01T12:02:06.000Z</updated>
        <content type="html"><![CDATA[<p>忙人请跳过以下内容：</p>
<hr>
<p>VECTAR的题目真的是不好做，调了一个晚上都没调出来。</p>
<p>做法显然 : 找规律 <s>打表</s></p>
<hr>
<p>好了，言归正传。</p>
<p>一开始看到这样的题目感觉很简单啊，直接使用<code>STL</code>的队列模拟，然后输出最后一张没出队的牌不就行了吗。</p>
<p>瞄了一眼数据范围......</p>
<blockquote>
<p>输入最多包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">5\times10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>行</p>
</blockquote>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">N \leq 10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></p>
</blockquote>
<p>一想肯定超时了。</p>
<p>可我还是打出了代码，代码如下：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;          //万能头
using namespace std;             //个人习惯
int n;
queue &lt;int&gt; q;                   //STL队列
int main(){
	ios::sync_with_stdio(false);   //取消同步
	cin&gt;&gt;n;                 //先输入一次
	while(n!=0){              //N还要处理
		for(int i=1;i&lt;=n;i++) q.push(i);//初始状态
		while(q.size()&gt;1){          //还可以pop()
			if(q.size()&gt;1) q.pop();   //先拿走最上面的牌
			if(q.size()&gt;1) q.push(q.front()),q.pop();再把最上面的牌移到堆底（队首）
		}
		cout&lt;&lt;q.front()&lt;&lt;endl; //最后剩下1张牌
		q.pop();cin&gt;&gt;n;      //清空队列，再次输入
	}
	return 0;
   别抄，这是错的。
}
</code></pre>
<p>我没有把这一份代码交上去，而是写了一个打表程序，就在上面加一个 <code>freopen</code>，把 <code>while(n!=0)</code> 改成<code>for(n=1;n&lt;=1000000;n++)</code> 就可以了。</p>
<p>但是出题人明摆着&quot;想打表？不可能！&quot; 的思想，让你这个程序跑得超级慢。</p>
<p>那还能怎么办 ?</p>
<p>找规律呗 ! 整个数列我不给了，就是展示一下重要的几项：</p>
<pre><code>1,2,2,4,2,4,6,8,2,4,6,8,10,12,14,16...250,252,254,256,2......
</code></pre>
<p>发现什么规律了没 ?</p>
<p>除了最开始的1,2 其他的每一项都是前一项 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">2</span></span></span></span> 。</p>
<p>但是如果前面一项是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> (n是正整数)，那么它的下一项就是 2 。看一下递推式</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>x</mi></msub><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>f</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>(</mo><msub><mi>f</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msub><mpadded width="0px"><mo></mo></mpadded><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>(</mo><msub><mi>f</mi><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup><mo>)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">f_x =
\begin{cases}
f_{x-1}+2&amp;(f_{x-1}\not=2^n)  \\
2&amp;(f_{x-1}=2^n)       
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>找到了规律就很好办，那我就上 AC 代码了。</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
long long f[1000001],dans=4;      //f用来递推,dans用来判断是不是 2 的整数次幂。
//因为我这里先计算了f[1]和f[2]，所以直接设置为 4。
int maxn;                   //记录递推边界
vector&lt;int&gt;v(1);              //输入用的
int n,j;                   //j用来记录算到哪里了
int main(){
	ios::sync_with_stdio(false);  //取消同步
	cin&gt;&gt;n;                //先输一次，就不用特判了
	while(n!=0)             //输入
		if(n!=0){
			v.push_back(n);
			if(maxn==0||n&gt;maxn) maxn=n;
			cin&gt;&gt;n;
		}
	f[1]=1;f[2]=0;j=3;        //f[2]设置为0为了更好计算 f[3]
	while(j&lt;=maxn){          //求到边界就可以
		f[j]=f[j-1]+2;        //递推式
		if(f[j]==dans){       //是2的整次幂
			j++;f[j]=2;dans*=2; //下一位是2，dans乘2
         //dalao可以使用位运算
		}
		j++;              //计算下一个没计算的数
	}
	f[2]=2;              //把f[2]调回去
	for(int i=1;i&lt;v.size();i++)//输出
		cout&lt;&lt;f[v[i]]&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>所以整体上说难度还不是很大。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 SP34009 【CTTC - Counting Child】]]></title>
        <id>https://dragon-skies.github.io/post/SP34009/</id>
        <link href="https://dragon-skies.github.io/post/SP34009/">
        </link>
        <updated>2020-02-28T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>这道题目提交了三次才过 。<s>我绝对不会告诉你们我是写错了格式 ，把 Case 写成了 case</s> 。</p>
<p>好的，言归正传 ：</p>
<p>做这一题你首先要学会什么是树 ，什么是树的遍历。</p>
<p>如果不知道就找一下万能的百度吧 ！</p>
<p>好 ， 拿到这一道题目首先想问 ， 每个节点不是只能访问一次吗 ？ 为什么遍历每个节点有两个呢 ？</p>
<p>想了十分钟才想明白 <s>好菜</s>， 像下面这个只有三个节点的树。（画图技术不是很好请谅解）</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/02/17/H48AQWJEsBZF3ge.png" alt="" loading="lazy"></figure>
<p>它的遍历顺序是 1 2 2 3 3 1 .</p>
<p>观察这个序列 ， 发现了什么 ？</p>
<p><strong>多了一个回溯的顺序</strong></p>
<p>也就是说，当输入一个节点的时候，前面没有 DFS 这个节点，则 DFS 这个节点，如果前面 DFS 过了，那么就跳出这个 DFS 。</p>
<p>根据 DFS 的特点（ 深度优先，当遍历到一个节点时，接下来就遍历这个数的子树 ） ，我们可以得出一个结论：</p>
<ol>
<li>设第一个输入的数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">a_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，第二个数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">a_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，第三个数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">a_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ......</li>
<li>在 a 这个数列里面，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub><mo>=</mo><msub><mi>a</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">a_l = a_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的时候，区间 [l,r] 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>l</mi></msub></mrow><annotation encoding="application/x-tex">a_l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 这个节点的 DFS 过程。</li>
</ol>
<p>DFS，DFS，DFS！这是怎么实现的呢？</p>
<p>递归。一想到递归，我就想到了栈（因为这个题目给了回溯的过程）。</p>
<p>那么我们可以用一个栈来模拟 DFS 的过程。做法如下：</p>
<ol>
<li>当输入一个节点的编号的时候，如果这个节点还没有输入国（就是还没有开始 DFS ）我们就把这个节点的编号加入到栈里面。</li>
<li>如果这个节点已经输入过了，那么说明这是个回溯的过程，就把当前的栈顶出栈（因为 DFS 的特性，最后递归的一定是最先返回的，所以我们能肯定当前出栈的一定就是输入的这个元素，不信可以试试看）</li>
<li>在回溯的过程当中，我们先把栈顶出栈，再把出栈后的栈顶的儿子的数量+1.（还是因为 DFS 的特性，我们搜完这个节点，返回这个节点的父节点的位置，而我们返回的这个父节点就多了一个儿子）</li>
</ol>
<p>看起来貌似可以了？模拟一下第一个样例：</p>
<pre><code>3
1 2 2 3 3 1
</code></pre>
<p>最开始栈为空，再 1 入栈， 2 入栈， 2 出栈，此时 1 的儿子数量 +1 ， 3 入栈， 3 出栈， 1 的儿子数量加 1 , 1 出栈，结束。</p>
<p>1有2个儿子，2 ， 3 没有儿子。Great！正确！</p>
<p>但是你光会这个没有用，还要注意一点细节的东西：</p>
<ol>
<li>输出格式别搞错了，我就这样WA了两次</li>
<li>本题有多组测试数据，输入用的数组可以不清 0 ，但是统计数据一定要清 0！</li>
<li>是输入 n*2 个节点，而不是 n 个！</li>
</ol>
<p>好了，说了这么多，给个你们最喜欢的代码：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;               //万能头好评
using namespace std;                 //个人习惯
int t,n,a[201],b[101];bool f[101];       //t表示测试数据个数，a是输入的数组，b是统计答案用的数组，f标记有没有入过栈。
stack &lt;int&gt; s;                     //当然您高兴的话手写栈也是可以的
int main(){
	ios::sync_with_stdio(false);        //取消同步
	cin&gt;&gt;t;
	for(int i=1;i&lt;=t;i++){
		cin&gt;&gt;n;
		for(int j=1;j&lt;=n*2;++j){
			cin&gt;&gt;a[j];               //输入一个节点
			if(!f[a[j]]){             //如果没有入过栈
				s.push(a[j]);f[a[j]]=true; //那就入栈并标记
			}
			else if(s.top()!=1){        //否则就出栈，并且把父节点的儿子个数+1.
            //需要注意的是，如果栈里面只有1一个元素，会因为栈空了导致RE，一定要特判
				s.pop();b[s.top()]++;
			}
		}
		cout&lt;&lt;&quot;Case &quot;&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;endl;         //格式别搞错了
		for(int i=1;i&lt;=n;++i) cout&lt;&lt;i&lt;&lt;&quot; -&gt; &quot;&lt;&lt;b[i]&lt;&lt;endl;
		memset(b,0,sizeof(b));
		memset(f,false,sizeof(f));          //重新初始化。
		s.pop();cout&lt;&lt;endl;               //注意格式，并且还要把最后剩下的 1 删除。
	}
}
一定要注意细节哦！（防作弊大法好）
</code></pre>
<p>个人认为这道题目的难度是<code>普及-</code>，主要是能想到栈的应用。</p>
<p>代码细节倒不是很多，主要就是判断一下栈里面只有元素 1 这一种可能</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P3197 [HNOI2008]越狱]]></title>
        <id>https://dragon-skies.github.io/post/P3197/</id>
        <link href="https://dragon-skies.github.io/post/P3197/">
        </link>
        <updated>2020-02-13T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>原题：<a href="https://www.luogu.com.cn/problem/P3197">P3197 [HNOI2008]越狱</a></p>
<p>这题目一看，算可能越狱的情况不好算，那就算出总情况，在算出不会越狱的情况再相减就行了</p>
<p>总的情况数： 第一间有 m 种选择，第二间有 m 种选择，第三间有 m 种选择 ......</p>
<p>所以一共有：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>m</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">m^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种选择。</p>
<p>不会发生的情况数：第一间有 m 种选择，第二间有 (m-1) 种选择，第三间有 (m-1) 种选择......</p>
<p>所以一共有：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>∗</mo><mo>(</mo><mi>m</mi><mo>−</mo><mn>1</mn><msup><mo>)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">m*(m-1)^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span> 种选择。</p>
<p>使用快速幂，复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(log_2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，应该可以通过。</p>
<p>代码如下：（记得开long long，记得每次计算都要取模）</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
#define ll long long
#define hash 100003
using namespace std;
ll n,m;
ll fpow(ll a,ll b){

	ll ans=1;
	while(b&gt;0){

		if(b%2!=0) ans=ans*a%hash;
		a=a*a%hash;
		b&gt;&gt;=1;

	}
	return ans;
}
int main(){

	ios::sync_with_stdio(false);

	cin&gt;&gt;m&gt;&gt;n;
	cout&lt;&lt;fpow(m,n)-(m*fpow(m-1,n-1))%hash;
	return 0;
}
</code></pre>
<p><img src="https://i.loli.net/2020/02/10/Wemn8ZNl9fhrxcq.png" alt="评测记录：" loading="lazy"><br>
乍一看，70分!!!哪里错了呢?</p>
<p>我发了一个讨论区，请求dalao的帮助，于是dalao们帮助了我。</p>
<p>是这样的：<code>fpow(m,n)-(m*fpow(m-1,n-1))%hash</code>在模意义下可能会小于0，（即模意义下fpow(m,n)小于(m*fpow(m-1,n-1)）</p>
<p>所以改了一下，100分代码如下：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
#define ll long long
#define ha 100003
using namespace std;
ll n,m;
ll fpow(ll a,ll b){

    ll ans=1;
    while(b&gt;0){

        if(b%2!=0) ans=ans*a%ha;
        a=a*a%ha;
        b&gt;&gt;=1;

    }
    return ans;
}
int main(){

    ios::sync_with_stdio(false);

    cin&gt;&gt;m&gt;&gt;n;
    cout&lt;&lt;(fpow(m,n)-(m*fpow(m-1,n-1))%ha+ha)%ha;
    return 0;
}
</code></pre>
<p>总结：在有模运算的时候一定要注意，会不会有出现负数的情况。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++普及数据结构模板]]></title>
        <id>https://dragon-skies.github.io/post/PJmodel-shujujiegou/</id>
        <link href="https://dragon-skies.github.io/post/PJmodel-shujujiegou/">
        </link>
        <updated>2020-02-02T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>node为变量类型，可以自由定义，以下不再赘述。</p>
<h2 id="1-线性表">1. 线性表</h2>
<p>1.1.栈</p>
<pre><code class="language-c++">struct stack{                        
	int tot;
   node s[MAXN];
	stack(){tot=0;}
	bool empty(){return tot==0;}
	int size(){return tot;}
	node top(){return s[tot];}
	int pop(){
		if(empty()) return 0;
		else{return tot--;} 
	}
	void push(int x){
		s[++tot]=x;
	}
};
</code></pre>
<p>1.2.队列</p>
<pre><code class="language-c++">struct queue{
    int l,r,cnt;node qu[N];
    node front(){return qu[l];}
    void ne(int &amp;x){++x;if(x==N) x=1;}
    void push(node x){ne(r);qu[r]=x;++cnt;}
    void pop(){ne(l);--cnt;}
    bool empty(){return !cnt;}
    int size(){return cnt;}
    void clear(){r=cnt=0,l=1;}
};
</code></pre>
<p>1.3.双向队列</p>
<pre><code class="language-c++">struct deque{
    int l,r,cnt;node qu[N];
    deque(){r=cnt=0,l=1;}
    node front(){return qu[l];}
    node back(){return qu[r];}
    void ne(int &amp;x){++x;if(x==N) x=1;}
    void la(int &amp;x){--x;if(!x) x=N-1;}
    void push_front(node x){la(l);qu[l]=x;++cnt;}
    void push_back(node x){ne(r);qu[r]=x;++cnt;}
    void pop_front(){ne(l);--cnt;}
    void pop_back(){la(r);--cnt;}
    bool empty(){return !cnt;}
    void size(){return cnt;}
    void clear(){r=cnt=0,l=1;}
};
</code></pre>
<p>1.4.链表</p>
<pre><code class="language-c++">struct List{
	int s,ne,la;
	List(int q=0,int n=-1,int p=-1){s=q;ne=n;la=p;}
};
vector &lt;List&gt; l(1);
void push(int x){
	int tot=l.size();
	l[tot-1].ne=tot;
	l.push_back(List(x,-1,tot-1));
}
void pop(int x){
	l[x-1].ne = x+1;
	l[x+1].la = x-1;
}
</code></pre>
<p>1.5.并查集</p>
<pre><code class="language-c++">struct unionFind{
	int bin[MAXN];
	unionFind(){for(int i=1;i&lt;=5000;++i) bin[i]=i;}
	int find(int x){
		if(bin[x]==x) return x;
		return find(bin[x]);
	}
	bool ask(int x,int y){
		if(find(x)==find(y)) return true;
		return false;
	}
	int insert(int x,int y){return bin[find(y)]=find(x);}
	int del(int x){bin[x]=0;}
};
</code></pre>
<h2 id="2树">2.树</h2>
<p>2.1. （大根）堆（优先队列）</p>
<pre><code class="language-c++">#define swap(a,b) int t=a;a=b;b=t;
struct heap{
	int w[N];
	int tot;
	int top(){return w[1];}
	void modify(int x){
		if(x==1) return ;
		if(w[x]&gt;w[x&gt;&gt;1]){
			swap(w[x],w[x&gt;&gt;1]);
			modify(x&gt;&gt;1);
		}
	}
	void push(int k){
		w[++tot]=k;
		modify(tot);
	}
	void repair(int x){
		int tar=w[x&lt;&lt;1]&gt;w[x&lt;&lt;1|1]?x&lt;&lt;1:x&lt;&lt;1|1;
		if(w[x]&lt;w[tar]){
			swap(w[x],w[tar]);
			repair(tar);
		}
	}
	void pop(){
		swap(w[1],w[tot]);
		w[tot--]=0;
		repair(1);
	}
}h;
</code></pre>
<p>2.2. 二叉树</p>
<pre><code class="language-c++">struct node{
	int l,r,dad;
	node(){l=r=dad=-1;}
};
vector &lt;node&gt; t(1);
void add(int u,int a,int b){
	if(t.size()-1&lt;max(max(u,a),b)) t.resize(max(max(u,a),b)+1);
	if(a!=0) t[u].l=a,t[a].dad=u;
	if(b!=0) t[u].r=b,t[b].dad=u;
	return;
}
</code></pre>
<h2 id="3图论">3.图论</h2>
<p>1.邻接表存图</p>
<pre><code class="language-c++">struct edge{
	int to,w;
	edge(int _to=-1,int _w=-1){to=_to;w=_w;}
};
vector &lt;edge&gt; G[N];
inline void init(int n){
	for(int i=1;i&lt;=n;i++) G[i].resize(1);
	return;
}
inline void add(int u,int v,int w){
	G[u].push_back(edge(v,w));
	G[v].push_back(edge(u,w));
	return ;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 U108192 【T4】【Sakura】]]></title>
        <id>https://dragon-skies.github.io/post/U108192/</id>
        <link href="https://dragon-skies.github.io/post/U108192/">
        </link>
        <updated>2020-02-01T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="题解-u108192-t4sakura">题解 U108192 【T4】Sakura</h1>
<p>这道题难度其实还蛮大的，需要经过一系列的数学思考，而且最终代码写出来还 <code>90</code> 多行。</p>
<p>好了，话不多说，进入正题。</p>
<p>我还是分成几个部分来解决</p>
<h2 id="模拟变化过程">模拟变化过程：</h2>
<p>我们应该怎么模拟呢？</p>
<p>可以看到题目中的话：</p>
<blockquote>
<p>每一根枝条后面都只有一根枝条，有一根枝条后面没有纸条。</p>
</blockquote>
<p>理解过来就是这样的。</p>
<p>那像什么呢？链表。</p>
<p>这就是具有唯一一个前驱和唯一一个后继。</p>
<p>而且还会进行链表的修改，明显链表的复杂度优于普通的线性表。</p>
<p>链表代码如下：</p>
<pre><code class="language-c++">struct sakura{    //存储每一根枝条，用的是链式结构
	long long s;  //注意这里要开 long long ，不然会WA
	int last,next;
	inline void init(int i,int n){//默认上一个的编号是i-1,下一个的编号是i+1.
		if(i==1) last=-1;//这需要特判
		else last=i-1;
		if(i==n) next=-1;//这也需要特判
		else next=i+1;
	}
};
sakura sak[100005];
inline void add(int x,int y){//把一根枝条插入到另一根枝条后面
	sak[sak[x].last].next = sak[x].next;
	sak[sak[x].next].last = sak[x].last;
	sak[x].last = y;
	sak[x].next= sak[y].next;
	sak[sak[y].next].last = x;
	sak[y].next = x;
	return;
}
</code></pre>
<p>好了，存储搞完了，该看看变化了。</p>
<p>其实加，乘就暴力完成，这里无法记录前缀和。（复杂度太高）</p>
<p>那我们是不是每输入一次就把所有需要干的事情做一遍呢？</p>
<p>不，不会的。</p>
<p>因为它保证了询问的时间是有序的，所以我们只需要问到那里做到哪里就可以了。</p>
<p>但是这里要注意，因为干的事情的时间不保证有序，所以我们需要先对他进行排序。</p>
<p>程序片段如下：</p>
<pre><code class="language-c++">ios::sync_with_stdio(false);
cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
for(int i=1;i&lt;=n;i++){//输入和初始化。
    cin&gt;&gt;sak[i].s;
    sak[i].init(i,n);
}
for(int i=1;i&lt;=m;i++){//输入一个变化，先不去做她，保存下来。
    cin&gt;&gt;q[i].tim&gt;&gt;q[i].pox&gt;&gt;q[i].x&gt;&gt;q[i].y;
    if(q[i].pox!=3) cin&gt;&gt;q[i].w;
}
sort(q+1,q+m+1,cmp);//按时间排序，这样就可以当队列拿来用了。
</code></pre>
<p>至此，模拟搞定了。</p>
<h2 id="回答询问">回答询问：</h2>
<p>接下来是怎么回答询问了。</p>
<p>这里需要对一些数进行加法，那还是暴力加。</p>
<p>但是求种数的时候就不能暴力计算了。</p>
<p>说不定复杂度是  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>5</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>那我们来用数学的角度算一算吧。</p>
<p>为了更好地测试，你可能需要以下的代码：</p>
<pre><code class="language-c++">//计算左闭右闭区间[a,b]中的所有数和左闭右闭区间[c,d]中的所有数的不重复排列
#include&lt;bits/stdc++.h&gt;
using namespace std;
int a,b,c,d,ans;
int main(){
	ios::sync_with_stdio(false);
	cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
	for(int i=a;i&lt;=b;i++)
		for(int j=c;j&lt;=d;j++)
			if(i!=j)
				ans++;
	cout&lt;&lt;ans&lt;&lt;endl;
	return 0;
}
</code></pre>
<h3 id="求区间排列之两个区间完全不重叠">求区间排列之——两个区间完全不重叠：</h3>
<p>例题：小蕊会从 1~10 中随机选一个数，小明会从11~20 中选一个数。她们选的数不相等的情况有几种？</p>
<p>列举一下完事嘛。</p>
<pre><code>1&amp;11 1&amp;12 1&amp;13 1&amp;14 1&amp;15 1&amp;16 1&amp;17 1&amp;18 1&amp;19 1&amp;20 
2&amp;11 2&amp;12 2&amp;13 2&amp;14 2&amp;15 2&amp;16 2&amp;17 2&amp;18 2&amp;19 2&amp;20 
3&amp;11 3&amp;12 3&amp;13 3&amp;14 3&amp;15 3&amp;16 3&amp;17 3&amp;18 3&amp;19 3&amp;20 
4&amp;11 4&amp;12 4&amp;13 4&amp;14 4&amp;15 4&amp;16 4&amp;17 4&amp;18 4&amp;19 4&amp;20 
5&amp;11 5&amp;12 5&amp;13 5&amp;14 5&amp;15 5&amp;16 5&amp;17 5&amp;18 5&amp;19 5&amp;20 
6&amp;11 6&amp;12 6&amp;13 6&amp;14 6&amp;15 6&amp;16 6&amp;17 6&amp;18 6&amp;19 6&amp;20 
7&amp;11 7&amp;12 7&amp;13 7&amp;14 7&amp;15 7&amp;16 7&amp;17 7&amp;18 7&amp;19 7&amp;20 
8&amp;11 8&amp;12 8&amp;13 8&amp;14 8&amp;15 8&amp;16 8&amp;17 8&amp;18 8&amp;19 8&amp;20 
9&amp;11 9&amp;12 9&amp;13 9&amp;14 9&amp;15 9&amp;16 9&amp;17 9&amp;18 9&amp;19 9&amp;20 
10&amp;11 10&amp;12 10&amp;13 10&amp;14 10&amp;15 10&amp;16 10&amp;17 10&amp;18 10&amp;19 10&amp;20 
</code></pre>
<p>一共 <code>100</code> 种方案 <s>手痛</s>。</p>
<p>可以看出，在两个区间不重复的情况下，小蕊可以从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>u</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">rui</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span></span></span></span> 个数中选一个，小明可以从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">ming</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 个数中选一个，那么选不同的数的方案数是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>u</mi><mi>i</mi><mo>×</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">rui \times ming
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span></span></p>
<p>解释一下：这就是乘法原理，因为两个不重叠区间不可能取到相同的数，让小蕊先选的话可以选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个，此时小可以选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">ming</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 个，所以一共可以选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">1 \times ming</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> ，但小蕊可以选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>u</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">rui</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span></span></span></span> 个，所方案数是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><mi>r</mi><mi>u</mi><mi>i</mi><mo>×</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>=</mo><mi>r</mi><mi>u</mi><mi>i</mi><mo>×</mo><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">1 \times rui \times ming=rui \times ming
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span></span></p>
<h2 id="求排列之两个区间有覆盖关系">求排列之——两个区间有覆盖关系：</h2>
<p>例题：小蕊会从 1~10 中随机选一个数，小明会从5~10 中选一个数。她们选的数不相等的情况有几种？</p>
<p>还是列举一下（用&amp;连接一种情况，用空格隔开不同的情况）：</p>
<pre><code>1&amp;5 1&amp;6 1&amp;7 1&amp;8 1&amp;9 1&amp;10 
2&amp;5 2&amp;6 2&amp;7 2&amp;8 2&amp;9 2&amp;10 
3&amp;5 3&amp;6 3&amp;7 3&amp;8 3&amp;9 3&amp;10 
4&amp;5 4&amp;6 4&amp;7 4&amp;8 4&amp;9 4&amp;10 
5&amp;6 5&amp;7 5&amp;8 5&amp;9 5&amp;10 
6&amp;5 6&amp;7 6&amp;8 6&amp;9 6&amp;10 
7&amp;5 7&amp;6 7&amp;8 7&amp;9 7&amp;10 
8&amp;5 8&amp;6 8&amp;7 8&amp;9 8&amp;10 
9&amp;5 9&amp;6 9&amp;7 9&amp;8 9&amp;10 
10&amp;5 10&amp;6 10&amp;7 10&amp;8 10&amp;9 
</code></pre>
<p><s>手又酸了</s></p>
<p>可以看得出来，一共有 45 种方案。</p>
<p>怎么算的呢？我们还是用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>u</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">rui</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span></span></span></span> 表示小蕊能选的数的个数， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">ming</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 表示小明能选的个数（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>u</mi><mi>i</mi><mtext> </mtext><mo>≥</mo><mtext> </mtext><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">rui\ \geq\ ming</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace"> </span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>）：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>×</mo><mo>(</mo><mi>r</mi><mi>u</mi><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">ming \times (rui-1)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p>
<p>解释一下：因为小蕊的区间覆盖了小明的区间，所以要让小明先选（不然可能小蕊选了数小明选数又发生了变化）。</p>
<p>小明可以选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">ming</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 个数。但是小蕊只能选 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>u</mi><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">rui-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个数（还有一个被小明用掉了）。</p>
<p>所以总方案数：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo>×</mo><mo>(</mo><mi>r</mi><mi>u</mi><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">ming \times (rui-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p>
<h3 id="求区间排列之两个区间部分重叠">求区间排列之——两个区间部分重叠：</h3>
<p>例题：小蕊会从 1~10 中随机选一个数，小明会从5~15 中选一个数。她们选的数不相等的情况有几种？</p>
<p>还是列举吧。</p>
<pre><code>1&amp;5 1&amp;6 1&amp;7 1&amp;8 1&amp;9 1&amp;10 1&amp;11 1&amp;12 1&amp;13 1&amp;14 1&amp;15 
2&amp;5 2&amp;6 2&amp;7 2&amp;8 2&amp;9 2&amp;10 2&amp;11 2&amp;12 2&amp;13 2&amp;14 2&amp;15 
3&amp;5 3&amp;6 3&amp;7 3&amp;8 3&amp;9 3&amp;10 3&amp;11 3&amp;12 3&amp;13 3&amp;14 3&amp;15 
4&amp;5 4&amp;6 4&amp;7 4&amp;8 4&amp;9 4&amp;10 4&amp;11 4&amp;12 4&amp;13 4&amp;14 4&amp;15 
5&amp;6 5&amp;7 5&amp;8 5&amp;9 5&amp;10 5&amp;11 5&amp;12 5&amp;13 5&amp;14 5&amp;15 
6&amp;5 6&amp;7 6&amp;8 6&amp;9 6&amp;10 6&amp;11 6&amp;12 6&amp;13 6&amp;14 6&amp;15 
7&amp;5 7&amp;6 7&amp;8 7&amp;9 7&amp;10 7&amp;11 7&amp;12 7&amp;13 7&amp;14 7&amp;15 
8&amp;5 8&amp;6 8&amp;7 8&amp;9 8&amp;10 8&amp;11 8&amp;12 8&amp;13 8&amp;14 8&amp;15 
9&amp;5 9&amp;6 9&amp;7 9&amp;8 9&amp;10 9&amp;11 9&amp;12 9&amp;13 9&amp;14 9&amp;15 
10&amp;5 10&amp;6 10&amp;7 10&amp;8 10&amp;9 10&amp;11 10&amp;12 10&amp;13 10&amp;14 10&amp;15 
</code></pre>
<p>其实这里也很好算，就是把小明的区间分成两个区间：跟小蕊重复的和不跟小蕊重复的。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">cf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 表示跟小蕊重复的，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><msub><mi>g</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">ming_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示不跟小蕊重复的）</p>
<p>那么重复的区间和小蕊选一个数的方案数是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>f</mi><mo>×</mo><mo>(</mo><mi>r</mi><mi>u</mi><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">cf \times (rui-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<p>那么不重复的区间和小蕊选一个数的方案数是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><msub><mi>g</mi><mn>1</mn></msub><mo>×</mo><mi>r</mi><mi>u</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">ming_1 \times rui</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span></span></span></span> 。</p>
<p>所以总方案数是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>f</mi><mo>×</mo><mo>(</mo><mi>r</mi><mi>u</mi><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>m</mi><mi>i</mi><mi>n</mi><msub><mi>g</mi><mn>1</mn></msub><mo>×</mo><mi>r</mi><mi>u</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">cf \times (rui-1) + ming_1 \times rui
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">i</span></span></span></span></span></p>
<p>我们可以发现，如果两个不重叠的区间套用这个公式，也是可以成立的（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>f</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">cf=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>），两个完全重叠的区间套用这个公式，让然成立（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><msub><mi>g</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">ming_1=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>）。</p>
<h2 id="应用到本题">应用到本题</h2>
<p>怎么应用呢？</p>
<p>我们还是用 $ rui$ 表示小蕊可选的总数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">cf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 表示重复的种数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><msub><mi>g</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">ming_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示小明的不合小蕊重复的种数。一样套用公式即可。</p>
<p>怎么求这三个数呢？</p>
<p>小蕊的就直接加，顺便对这个位置打上一个加了的标记。</p>
<p>小明加的时候就看有没有打这个标记：打了，就加到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">cf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> 里面去，没打，就加到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">ming</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span> 里面去。</p>
<p>至此，问题解决。</p>
<h2 id="代码">代码：</h2>
<p>完整代码：</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
const int ha=5201314;
using namespace std;
struct node{      //存储每一次变化
	int tim,pox,x,y,w;
};
struct sakura{    //存储每一根枝条，用的是链式结构
	long long s;  //注意这里要开 long long ，不然会WA
	int last,next;
	inline void init(int i,int n){//默认上一个的编号是i-1,下一个的编号是i+1.
		if(i==1) last=-1;//这需要特判
		else last=i-1;
		if(i==n) next=-1;//这也需要特判
		else next=i+1;
	}
};
sakura sak[100005];
inline void add(int x,int y){//把一根枝条插入到另一根枝条后面
	sak[sak[x].last].next = sak[x].next;
	sak[sak[x].next].last = sak[x].last;
	sak[x].last = y;
	sak[x].next= sak[y].next;
	sak[sak[y].next].last = x;
	sak[y].next = x;
	return;
}
node q[100005];bool vis[100005];//q其实就是队列，但会进行排序，vis表示有没有访问过，用来计算重复的。
int n,m,k,head=1;
inline void push_down(int x=head){//立刻做q[x]的事情。
	if(q[x].pox==1){//加
		int u=q[x].x; 
		for(int i=1;i&lt;=q[x].y;i++){
			sak[u].s=(sak[u].s+q[x].w)%ha;
			u=sak[u].next;
			if(u==-1) return;
		}
		return;
	}
	if(q[x].pox==2){//乘
		int u=q[x].x; 
		for(int i=1;i&lt;=q[x].y;i++){
			sak[u].s=(sak[u].s*q[x].w)%ha;
			u=sak[u].next;
			if(u==-1) return;
		}
		return;
	}
	if(q[x].pox==3){//把这根枝条插入到别的枝条后面。
		add(q[x].x,q[x].y);
		return;
	}
}
inline bool cmp(node a,node b){
    //排序用的比较函数，先做时间早的，时间一样那就做编号小的（先加在乘最后换位置）
	if(a.tim!=b.tim) return a.tim&lt;b.tim;
	return a.pox&lt;b.pox;
}
int main(){
	ios::sync_with_stdio(false);
	cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;
	for(int i=1;i&lt;=n;i++){//输入和初始化。
		cin&gt;&gt;sak[i].s;
		sak[i].init(i,n);
	}
	for(int i=1;i&lt;=m;i++){//输入一个变化，先不去做她，保存下来。
		cin&gt;&gt;q[i].tim&gt;&gt;q[i].pox&gt;&gt;q[i].x&gt;&gt;q[i].y;
		if(q[i].pox!=3) cin&gt;&gt;q[i].w;
	}
	sort(q+1,q+m+1,cmp);//按时间排序，这样就可以当队列拿来用了。
	for(int i=1;i&lt;=k;i++){
		int ti,a,b,c,d;//输入用的
		long long cf=0,rui=0,ming=0;//cf记录重复的，rui记录小蕊的，ming记录小明的。
		cin&gt;&gt;ti&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
		while(head&lt;=m&amp;&amp;q[head].tim&lt;=ti)//先把要干的事情干完
			push_down(head++);
		int u=a;//先求小蕊的，这里不用算重复，只用标记一下就可以了。
		for(int j=1;j&lt;=b+1;j++){
			rui=(rui+sak[u].s)%ha;//记得取模
			vis[u]=true;//标记一下
			u=sak[u].next;
			if(u==-1) break;
		}
		u=c;
		for(int j=1;j&lt;=d+1;j++){//再求小明的，这里就需要计算重复了。
			if(vis[u]) cf=(cf+sak[u].s)%ha;//算过了的，取模
			else ming=(ming+sak[u].s)%ha;//没算过。
			u=sak[u].next;
			if(u==-1) break;
		}
        //这里并没有给小蕊减掉重复，因为把小蕊的看成一个整体，把小明的分开算就行了。
		cout&lt;&lt;((cf*(rui-1)%ha)+(ming*rui%ha))%ha&lt;&lt;endl;//公式，记得多取一下模。
		memset(vis,0,sizeof(vis)); //注意这里要重新初始化，不然会发生一些奇奇怪怪的错误。
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++入门模板]]></title>
        <id>https://dragon-skies.github.io/post/RMmodel/</id>
        <link href="https://dragon-skies.github.io/post/RMmodel/">
        </link>
        <updated>2020-01-01T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="质数专题">质数专题</h2>
<p>判断素数</p>
<pre><code class="language-c++">bool isprime(int n){
	if(n==1||n==0) return false;
	for(int i=2;i*i&lt;=n;i++) if(n%i==0) return false;
   return ture;
}
</code></pre>
<p>埃氏筛</p>
<pre><code class="language-c++">bool f[N];
void Prime(int n){
	memset(f,true,sizeof(f));f[1]=f[0]=false;
	for(int i=2;i&lt;=n;i++)
		if(f[i])
			for(int j=2;i*j&lt;=n;j++)
				f[i*j]=false;
}
</code></pre>
<p>欧几里得筛</p>
<pre><code class="language-c++">vector &lt;int&gt; sprime(1);
int cnt;bool isprime[100000001];
void Sprime(int n){
	memset(isprime,true,sizeof(isprime));
	isprime[1]=isprime[0]=false;
	for(int i=2;i&lt;=n;i++){
		if(isprime[i]){
			cnt++;sprime.push_back(i);
		}
		for(int j=1;j&lt;=cnt&amp;&amp;i*sprime[j]&lt;=n;j++){
			isprime[i*sprime[j]]=false;
			if(i%sprime[j]==0)
				break;
		}
	}
}
</code></pre>
<h2 id="排序专题">排序专题</h2>
<p>快速排序</p>
<pre><code class="language-c++">void qsort(int a[],int l,int r){//对a数组进行从小到大排序 
	int mid=(l+r)/2,i=l,j=r;
	do{
		while(a[i]&lt;a[mid]) i++;
		while(a[j]&gt;a[mid]) j--;
		 if(i&lt;=j){
			swap(a[i],a[j]);
			i++;j--;
		 }
	}while(i&lt;=j);
	if(l&lt;j) qsort(a,l,j);
	if(i&lt;r) qsort(a,i,r);
	return;
}
</code></pre>
<p>归并排序</p>
<pre><code class="language-c++">void msort(int a[],int l,int r,bool(*cmp)(int,int)){
	if(l&gt;=r) return;
	int mid=(l+r)&gt;&gt;1,i=l,j=mid+1,t=0;
	msort(a,l,mid,cmp);
	msort(a,mid+1,r,cmp);
	while(i&lt;=mid&amp;&amp;j&lt;=r){
		if(cmp(a[i],a[j])) 
			b[++t]=a[j++];
		else 
			b[++t]=a[i++];
	}
	while(i&lt;=mid) b[++t]=a[i++];
	while(j&lt;=r)   b[++t]=a[j++];
	for(i=1;i&lt;=t;i++) a[l+i-1]=b[i];
	return ;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P5682 [CSPJX2019]次大值【民间数据】]]></title>
        <id>https://dragon-skies.github.io/post/P5682/</id>
        <link href="https://dragon-skies.github.io/post/P5682/">
        </link>
        <updated>2019-11-18T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>2020-2-3:修改了几个错字,增加了一些注释与例子.</p>
<p>还好这道题目简单,要不然我就没有入门组一等奖了.</p>
<p><s>还好重考了,要不然我只有100分</s></p>
<p>好的,切入正题</p>
<p>这个题目其实可以暴力做</p>
<p>每个数对其他的数进行取模 , 复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> , 最少拿个40分 ,  说不定运气好多拿点分</p>
<p>但实际上要拿满分 , 要用到一句话:</p>
<p><strong>真正的高手不用暴力,他用的是数学.</strong></p>
<h4 id="从取模的性质去考虑吧">从取模的性质去考虑吧</h4>
<ol>
<li>
<p>MOD (%) 运算 , 指两个数的余数.( a%b=a/b的余数 )</p>
</li>
<li>
<p>一个数模于另一个数(a % b(b <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">≠</mi></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 0)(a <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo></mrow><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span></span></span></span> b))的结果不可能大于b.</p>
</li>
<li>
<p>但是一个更小的数mod更大的数(a mod b(b&gt;a)) 所得的值还是它本身 (a) .</p>
</li>
</ol>
<h4 id="综上所述我们得出一个结论">综上所述，我们得出一个结论:</h4>
<blockquote>
<ul>
<li>在一个数列里的数能得到的最大的模数就是他本身.</li>
</ul>
</blockquote>
<p>题目要求mod的次大值. 次大值就是第三大的数(最大的是第二大的数,如果没有第三大的数,则需要输出-1)</p>
<p>于是可以上代码了</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[2*1000001],n,b,c,maxn;
//a数组存储数据,n总数,b,c用来找数,maxn是答案.
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]);
	//在处理之前,先要排序 
	sort(a+1,a+n+1);
	//找数部分 
	for(int i=n;1;--i){
		//如果没有答案,输出-1 
		if(i==0){
			printf(&quot;-1&quot;);
			return 0;
		}
		//暂时先定答案 
		maxn = a[i];
		if(b==0) b=a[i];
		if(c==0&amp;&amp;b!=0&amp;&amp;a[i]!=b) c=a[i];
		//找到了退出 
		if(b!=0&amp;&amp;c!=0&amp;&amp;a[i]!=b&amp;&amp;a[i]!=c) break;
	}
	//输出最大的数.
	printf(&quot;%d&quot;,maxn);
	return 0;
}
</code></pre>
<p>当然啦 , 如果你想我这样写 , 那么恭喜你 , 你成功在CSP-JX入门组的 [T2] 得了50分.</p>
<p>为什么呢 ? 设想一下 , 如果是在极端情况下 , 最大的数模于第二大的数可能会大于第三大的数.</p>
<p>例如:  1 10 19</p>
<p>正确答案是 9,而如果按上面的程序,它会输出1.</p>
<p>所以一定要考虑到问题的多样性!!!</p>
<p>正确代码:</p>
<pre><code class="language-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[2*1000001],n,b,c,maxn;
//a数组存储数据,n总数,b,c用来找数,maxn是答案.
int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]);
	sort(a+1,a+n+1);  //在处理之前,先要排序 
	for(int i=n;1;--i){
		if(i==0){
			printf(&quot;-1&quot;); //如果没有答案,输出-1 
			return 0;
		}
		//找到了退出 
		maxn = a[i];
		if(b==0) b=a[i];
		if(c==0&amp;&amp;b!=0&amp;&amp;a[i]!=b) c=a[i];
		if(b!=0&amp;&amp;c!=0&amp;&amp;a[i]!=b&amp;&amp;a[i]!=c) break;
	}
	//把第三大的数和最大的数mod第二大的比较 
	printf(&quot;%d&quot;,max(maxn,a[n]%a[n-1]));
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>